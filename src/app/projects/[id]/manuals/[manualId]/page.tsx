'use client';

import { useEffect, useState } from 'react';
import { useParams, useRouter } from 'next/navigation';
import { 
  Card, 
  CardBody, 
  CardHeader,
  Button as HeroButton,
  Input,
  Chip,
  Dropdown,
  DropdownTrigger,
  DropdownMenu,
  DropdownItem,
  Tabs,
  Tab,
  Select,
  SelectItem,
} from '@heroui/react';
import { 
  BookOpenIcon,
  PlusIcon,
  TrashIcon,
  ArrowPathIcon,
  ArrowDownTrayIcon,
  ChevronRightIcon,
  ChevronDownIcon,
  Bars3Icon,
} from '@heroicons/react/24/outline';
import { AppLayout, Modal, SkeletonCard } from '@/components';
import { ManualPreview } from '@/components/manual/ManualPreview';
import { Manual, ManualSection } from '@/types/electron';
import { ManualTable } from '@/types/project.types';

export default function ManualEditorPage() {
  const params = useParams();
  const router = useRouter();
  const manualId = params.manualId as string;
  const projectId = params.id as string;

  const [manual, setManual] = useState<Manual | null>(null);
  const [sections, setSections] = useState<ManualSection[]>([]);
  const [manualTables, setManualTables] = useState<ManualTable[]>([]);
  const [selectedManualTableId, setSelectedManualTableId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [selectedSection, setSelectedSection] = useState<ManualSection | null>(null);
  const [editingContent, setEditingContent] = useState('');
  const [editingTitle, setEditingTitle] = useState('');
  const [isSaving, setIsSaving] = useState(false);
  const [expandedSections, setExpandedSections] = useState<Set<string>>(new Set());
  const [activeTab, setActiveTab] = useState<string>('edit');
  
  // モーダル状態
  const [isAddSectionModalOpen, setIsAddSectionModalOpen] = useState(false);
  const [newSectionTitle, setNewSectionTitle] = useState('');
  const [newSectionParentId, setNewSectionParentId] = useState<string | null>(null);

  useEffect(() => {
    loadManual();
  }, [manualId]);

  const loadManual = async () => {
    setIsLoading(true);
    try {
      // マニュアルテーブル一覧を取得
      const tables = await window.electronAPI.manualTable.getByProject(projectId);
      setManualTables(tables);
      
      // マニュアル情報を取得
      const manuals = await window.electronAPI.manual.getByProject(projectId);
      const currentManual = manuals.find((m: Manual) => m.id === manualId);
      
      if (!currentManual) {
        alert('マニュアルが見つかりません');
        router.push(`/projects/${projectId}/manuals`);
        return;
      }
      
      setManual(currentManual);
      
      // デフォルトで最初のマニュアルテーブルを選択
      if (tables.length > 0 && !selectedManualTableId) {
        setSelectedManualTableId(tables[0].id);
      }
      
      // セクション一覧を取得（実装予定）
      // const sectionsData = await window.electronAPI.manual.getSections(manualId);
      // setSections(sectionsData);
      
      // デモデータ
      const demoSections: ManualSection[] = [
        {
          id: '1',
          manualId,
          title: '第1章 概要',
          content: '# 概要\n\nこのマニュアルは...',
          level: 1,
          displayOrder: 1,
          autoGenerated: true,
          syncStatus: 'synced',
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        },
        {
          id: '2',
          manualId,
          title: '1.1 目的',
          content: '## 目的\n\n[詳細は手動で入力してください]',
          level: 2,
          parentId: '1',
          displayOrder: 1,
          autoGenerated: true,
          syncStatus: 'synced',
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        },
      ];
      setSections(demoSections);
      
      // デフォルトで最初のセクションを選択
      if (demoSections.length > 0) {
        setSelectedSection(demoSections[0]);
        setEditingTitle(demoSections[0].title);
        setEditingContent(demoSections[0].content);
      }
    } catch (error) {
      console.error('[ManualEditor] Failed to load manual:', error);
      alert('マニュアルの読み込みに失敗しました');
    } finally {
      setIsLoading(false);
    }
  };

  const handleSaveSection = async () => {
    if (!selectedSection) return;
    
    setIsSaving(true);
    try {
      // セクション更新API（実装予定）
      // await window.electronAPI.manual.updateSection(selectedSection.id, {
      //   title: editingTitle,
      //   content: editingContent,
      // });
      
      // ローカル状態を更新
      setSections(sections.map(s => 
        s.id === selectedSection.id 
          ? { ...s, title: editingTitle, content: editingContent, updatedAt: new Date().toISOString() }
          : s
      ));
      
      setSelectedSection({ ...selectedSection, title: editingTitle, content: editingContent });
      
      alert('保存しました');
    } catch (error) {
      console.error('[ManualEditor] Failed to save section:', error);
      alert('保存に失敗しました');
    } finally {
      setIsSaving(false);
    }
  };

  const handleAddSection = async () => {
    if (!newSectionTitle.trim()) {
      alert('セクションタイトルを入力してください');
      return;
    }
    
    try {
      // セクション作成API（実装予定）
      const newSection: ManualSection = {
        id: Date.now().toString(),
        manualId,
        title: newSectionTitle,
        content: '[詳細は手動で入力してください]',
        level: newSectionParentId ? 2 : 1,
        parentId: newSectionParentId || undefined,
        displayOrder: sections.filter(s => s.parentId === newSectionParentId).length + 1,
        autoGenerated: false,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };
      
      setSections([...sections, newSection]);
      setIsAddSectionModalOpen(false);
      setNewSectionTitle('');
      setNewSectionParentId(null);
    } catch (error) {
      console.error('[ManualEditor] Failed to add section:', error);
      alert('セクションの追加に失敗しました');
    }
  };

  const handleDeleteSection = async (sectionId: string) => {
    if (!confirm('このセクションを削除してもよろしいですか？')) {
      return;
    }
    
    try {
      // セクション削除API（実装予定）
      setSections(sections.filter(s => s.id !== sectionId));
      
      if (selectedSection?.id === sectionId) {
        const remaining = sections.filter(s => s.id !== sectionId);
        if (remaining.length > 0) {
          setSelectedSection(remaining[0]);
          setEditingTitle(remaining[0].title);
          setEditingContent(remaining[0].content);
        } else {
          setSelectedSection(null);
          setEditingTitle('');
          setEditingContent('');
        }
      }
    } catch (error) {
      console.error('[ManualEditor] Failed to delete section:', error);
      alert('セクションの削除に失敗しました');
    }
  };

  const handleSyncWithProcesses = async () => {
    if (!manual) return;
    
    try {
      // Phase 6では手動同期
      alert('この機能は今後のアップデートで実装予定です。\n現在は手動でマニュアルを更新してください。');
      await loadManual();
    } catch (error) {
      console.error('[ManualEditor] Failed to sync:', error);
      alert('同期に失敗しました');
    }
  };

  const handleExport = async (format: 'markdown' | 'html' | 'pdf') => {
    if (!manual) return;
    
    try {
      await window.electronAPI.manual.export(manual.id, format);
      alert(`${format.toUpperCase()}形式でエクスポートしました`);
    } catch (error) {
      console.error('[ManualEditor] Failed to export:', error);
      alert('エクスポートに失敗しました');
    }
  };

  const toggleSectionExpand = (sectionId: string) => {
    const newExpanded = new Set(expandedSections);
    if (newExpanded.has(sectionId)) {
      newExpanded.delete(sectionId);
    } else {
      newExpanded.add(sectionId);
    }
    setExpandedSections(newExpanded);
  };

  const renderSectionTree = (parentId: string | null = null, level: number = 0) => {
    const childSections = sections.filter(s => (s.parentId || null) === parentId);
    
    return childSections.map(section => {
      const hasChildren = sections.some(s => s.parentId === section.id);
      const isExpanded = expandedSections.has(section.id);
      const isSelected = selectedSection?.id === section.id;
      
      return (
        <div key={section.id}>
          <div
            className={`flex items-center gap-2 px-3 py-2 rounded-lg cursor-pointer transition-colors ${
              isSelected
                ? 'bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-200'
                : 'hover:bg-gray-100 dark:hover:bg-gray-700'
            }`}
            style={{ paddingLeft: `${level * 20 + 12}px` }}
            onClick={() => {
              setSelectedSection(section);
              setEditingTitle(section.title);
              setEditingContent(section.content);
            }}
          >
            {hasChildren && (
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  toggleSectionExpand(section.id);
                }}
                className="flex-shrink-0"
              >
                {isExpanded ? (
                  <ChevronDownIcon className="w-4 h-4" />
                ) : (
                  <ChevronRightIcon className="w-4 h-4" />
                )}
              </button>
            )}
            {!hasChildren && <div className="w-4" />}
            
            <span className="flex-1 text-sm truncate">{section.title}</span>
            
            {section.syncStatus === 'modified' && (
              <Chip size="sm" color="warning" variant="flat">変更</Chip>
            )}
            {section.syncStatus === 'conflict' && (
              <Chip size="sm" color="danger" variant="flat">競合</Chip>
            )}
            
            <button
              onClick={(e) => {
                e.stopPropagation();
                handleDeleteSection(section.id);
              }}
              className="flex-shrink-0 p-1 hover:bg-red-100 dark:hover:bg-red-900 rounded"
            >
              <TrashIcon className="w-4 h-4 text-red-500" />
            </button>
          </div>
          
          {hasChildren && isExpanded && renderSectionTree(section.id, level + 1)}
        </div>
      );
    });
  };

  if (isLoading) {
    return (
      <AppLayout>
        <div className="space-y-6">
          <SkeletonCard />
          <div className="grid grid-cols-12 gap-6">
            <div className="col-span-3">
              <SkeletonCard />
            </div>
            <div className="col-span-9">
              <SkeletonCard />
            </div>
          </div>
        </div>
      </AppLayout>
    );
  }

  if (!manual) {
    return (
      <AppLayout>
        <div className="flex flex-col items-center justify-center h-full">
          <p className="text-lg text-gray-500">マニュアルが見つかりません</p>
          <HeroButton
            color="primary"
            className="mt-4"
            onClick={() => router.push(`/projects/${projectId}/manuals`)}
          >
            マニュアル一覧に戻る
          </HeroButton>
        </div>
      </AppLayout>
    );
  }

  return (
    <AppLayout>
      <div className="space-y-6">
        {/* ヘッダー */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <HeroButton
              variant="light"
              onClick={() => router.push(`/projects/${projectId}/manuals`)}
              startContent={<span className="text-xl">←</span>}
            >
              マニュアル一覧に戻る
            </HeroButton>
            <div className="border-l border-gray-300 dark:border-gray-700 h-6 mx-2" />
            <BookOpenIcon className="w-8 h-8 text-blue-500" />
            <div>
              <h1 className="text-2xl font-bold text-gray-900 dark:text-gray-50">
                {manual.title}
              </h1>
              {manual.autoGenerated && (
                <Chip size="sm" color="secondary" variant="flat" className="mt-1">
                  自動生成
                </Chip>
              )}
            </div>
          </div>

          <div className="flex gap-2">
            {/* マニュアルテーブル選択 */}
            {manualTables.length > 0 && (
              <Select
                label="グループ"
                placeholder="グループを選択"
                selectedKeys={selectedManualTableId ? [selectedManualTableId] : []}
                onChange={(e) => setSelectedManualTableId(e.target.value)}
                className="w-64"
                size="sm"
              >
                {manualTables.map((table) => (
                  <SelectItem key={table.id}>
                    {table.name}
                  </SelectItem>
                ))}
              </Select>
            )}
            {manual.autoGenerated && (
              <HeroButton
                variant="bordered"
                onClick={handleSyncWithProcesses}
                startContent={<ArrowPathIcon className="w-5 h-5" />}
              >
                同期
              </HeroButton>
            )}
            <Dropdown>
              <DropdownTrigger>
                <HeroButton
                  variant="bordered"
                  startContent={<ArrowDownTrayIcon className="w-5 h-5" />}
                >
                  エクスポート
                </HeroButton>
              </DropdownTrigger>
              <DropdownMenu
                aria-label="エクスポート形式"
                onAction={(key) => handleExport(key as 'markdown' | 'html' | 'pdf')}
              >
                <DropdownItem key="markdown">Markdown</DropdownItem>
                <DropdownItem key="html">HTML</DropdownItem>
                <DropdownItem key="pdf">PDF</DropdownItem>
              </DropdownMenu>
            </Dropdown>
          </div>
        </div>

        {/* メインコンテンツ */}
        <div className="grid grid-cols-12 gap-6">
          {/* 左サイドバー - セクションツリー */}
          <div className="col-span-3">
            <Card className="shadow-sm">
              <CardHeader className="flex justify-between items-center p-4">
                <h2 className="text-lg font-semibold text-gray-900 dark:text-gray-50">
                  目次
                </h2>
                <HeroButton
                  size="sm"
                  color="primary"
                  isIconOnly
                  onClick={() => setIsAddSectionModalOpen(true)}
                >
                  <PlusIcon className="w-4 h-4" />
                </HeroButton>
              </CardHeader>
              <CardBody className="p-2">
                {sections.length === 0 ? (
                  <div className="text-center py-8">
                    <p className="text-sm text-gray-500 dark:text-gray-400">
                      セクションがありません
                    </p>
                    <HeroButton
                      size="sm"
                      color="primary"
                      variant="flat"
                      className="mt-3"
                      onClick={() => setIsAddSectionModalOpen(true)}
                      startContent={<PlusIcon className="w-4 h-4" />}
                    >
                      セクション追加
                    </HeroButton>
                  </div>
                ) : (
                  <div className="space-y-1">
                    {renderSectionTree()}
                  </div>
                )}
              </CardBody>
            </Card>
          </div>

          {/* メインエディタ */}
          <div className="col-span-9">
            <Card className="shadow-sm">
              <CardHeader className="p-0">
                <Tabs
                  selectedKey={activeTab}
                  onSelectionChange={(key) => setActiveTab(key as string)}
                  fullWidth
                  classNames={{
                    tabList: "rounded-t-lg",
                  }}
                >
                  <Tab key="edit" title="編集" />
                  <Tab key="preview" title="プレビュー" />
                </Tabs>
              </CardHeader>
              <CardBody className="p-0">
                {activeTab === 'edit' ? (
                  // 編集タブ
                  selectedSection ? (
                    <div className="p-4 space-y-4">
                      <Input
                        value={editingTitle}
                        onChange={(e) => setEditingTitle(e.target.value)}
                        placeholder="セクションタイトル"
                        classNames={{
                          input: "text-lg font-semibold",
                          inputWrapper: "shadow-none",
                        }}
                      />
                      <textarea
                        value={editingContent}
                        onChange={(e) => setEditingContent(e.target.value)}
                        placeholder="Markdown形式で内容を入力してください"
                        rows={20}
                        className="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-lg text-gray-900 dark:text-gray-50 placeholder-gray-500 dark:placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none font-mono text-sm"
                      />
                      
                      <div className="flex justify-between items-center">
                        <div className="text-xs text-gray-500 dark:text-gray-400">
                          最終更新: {new Date(selectedSection.updatedAt).toLocaleString('ja-JP')}
                        </div>
                        <HeroButton
                          color="primary"
                          onClick={handleSaveSection}
                          disabled={isSaving}
                        >
                          {isSaving ? '保存中...' : '保存'}
                        </HeroButton>
                      </div>
                    </div>
                  ) : (
                    <div className="p-12 text-center">
                      <Bars3Icon className="w-16 h-16 text-gray-300 dark:text-gray-700 mx-auto mb-4" />
                      <h3 className="text-lg font-semibold text-gray-700 dark:text-gray-300 mb-2">
                        セクションを選択してください
                      </h3>
                      <p className="text-sm text-gray-500 dark:text-gray-400">
                        左側の目次からセクションを選択するか、新規作成してください
                      </p>
                    </div>
                  )
                ) : (
                  // プレビュータブ
                  <div className="p-6 max-h-[800px] overflow-y-auto">
                    {manual && (
                      <ManualPreview
                        title={manual.title}
                        sections={sections}
                        showTableOfContents={true}
                      />
                    )}
                  </div>
                )}
              </CardBody>
            </Card>
          </div>
        </div>

        {/* セクション追加モーダル */}
        <Modal
          isOpen={isAddSectionModalOpen}
          onClose={() => {
            setIsAddSectionModalOpen(false);
            setNewSectionTitle('');
            setNewSectionParentId(null);
          }}
          title="セクション追加"
        >
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium mb-2 text-gray-700 dark:text-gray-300">
                タイトル *
              </label>
              <Input
                value={newSectionTitle}
                onChange={(e) => setNewSectionTitle(e.target.value)}
                placeholder="セクションのタイトルを入力"
                fullWidth
              />
            </div>

            <div className="flex justify-end gap-2 pt-4">
              <HeroButton
                variant="bordered"
                onClick={() => {
                  setIsAddSectionModalOpen(false);
                  setNewSectionTitle('');
                  setNewSectionParentId(null);
                }}
              >
                キャンセル
              </HeroButton>
              <HeroButton
                color="primary"
                onClick={handleAddSection}
                disabled={!newSectionTitle.trim()}
              >
                追加
              </HeroButton>
            </div>
          </div>
        </Modal>
      </div>
    </AppLayout>
  );
}
