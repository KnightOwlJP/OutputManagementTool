import { getDatabase } from '../utils/database';

/**
 * ãƒãƒ‹ãƒ¥ã‚¢ãƒ«è‡ªå‹•ç”Ÿæˆã‚µãƒ¼ãƒ“ã‚¹
 * Phase 6.2.1 å®Ÿè£…
 * 
 * ğŸ“ Phase 6ã‚¹ã‚³ãƒ¼ãƒ—: ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ï¼ˆæ§‹é€ ï¼‰ã®ã¿ç”Ÿæˆ
 * ğŸ”® Phase 7: ç”ŸæˆAIã§è©³ç´°ã‚³ãƒ³ãƒ†ãƒ³ãƒ„è‡ªå‹•ç”Ÿæˆ
 */

export type ProcessLevel = 'large' | 'medium' | 'small' | 'detail';
export type SectionLevel = 'chapter' | 'section' | 'subsection' | 'step';
export type ExportFormat = 'pdf' | 'html' | 'markdown' | 'docx';

export interface Process {
  id: string;
  projectId: string;
  name: string;
  level: ProcessLevel;
  parentId?: string;
  department?: string;
  assignee?: string;
  documentType?: string;
  description?: string;
  bpmnElementId?: string;
  displayOrder: number;
  metadata?: Record<string, any>;
}

export interface Manual {
  id: string;
  projectId: string;
  title: string;
  content: string;
  targetProcessLevel: ProcessLevel;
  version: string;
  status: 'draft' | 'review' | 'approved' | 'outdated';
  author: string;
  autoGenerated: boolean;
  lastSyncAt?: number;
  createdAt: number;
  updatedAt: number;
  metadata?: Record<string, any>;
}

export interface ManualSection {
  id: string;
  manualId: string;
  sectionOrder: number;
  level: ProcessLevel;
  heading: string;
  content: string;
  processId: string;
  processLevel: ProcessLevel;
  bpmnElementId?: string;
  parentSectionId?: string;
  syncStatus: 'synced' | 'outdated' | 'conflict';
  autoGenerated: boolean;
  createdAt: number;
  updatedAt: number;
}

export interface GenerateOptions {
  manualTableId?: string; // ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ID
  includeLevels: ProcessLevel[];
  includeProcessIds?: string[];
  template?: 'business' | 'operation' | 'flowchart' | 'custom';
  autoSync?: boolean;
  includeBpmnImages?: boolean; // ğŸ”® Phase 7å®Ÿè£…äºˆå®š
  useAI?: boolean; // ğŸ”® Phase 7å®Ÿè£…äºˆå®š
  aiProvider?: 'openai' | 'anthropic' | 'custom'; // ğŸ”® Phase 7å®Ÿè£…äºˆå®š
}

export interface SyncResult {
  success: boolean;
  updatedCount: number;
  errors: string[];
}

export class ManualGenerator {
  private db: ReturnType<typeof getDatabase> | null = null;

  private getDb() {
    if (!this.db) {
      this.db = getDatabase();
    }
    return this.db;
  }

  /**
   * å·¥ç¨‹ç¾¤ã‹ã‚‰ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã‚’ç”Ÿæˆ
   * Phase 6å®Ÿè£…ç¯„å›²: æ§‹é€ ã®ã¿
   */
  async generateFromProcesses(
    projectId: string,
    title: string,
    options: GenerateOptions
  ): Promise<Manual> {
    console.log(`[ManualGenerator] ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ç”Ÿæˆé–‹å§‹: ${title}`);
    
    try {
      // 1. å·¥ç¨‹éšå±¤ã‚’å–å¾—
      const processes = this.getProcessesByProject(projectId, options);
      
      // 2. ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã‚’ä½œæˆ
      const manual = this.createManual(projectId, title, options);
      
      // 3. ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ§‹é€ ã‚’æ§‹ç¯‰
      const sections = this.buildSectionStructure(manual.id, processes);
      
      // 4. ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä¿å­˜
      for (const section of sections) {
        this.saveSection(section);
      }
      
      console.log(`[ManualGenerator] ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ç”Ÿæˆå®Œäº†: ${sections.length}ã‚»ã‚¯ã‚·ãƒ§ãƒ³`);
      return manual;
      
    } catch (error) {
      console.error('[ManualGenerator] ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error);
      throw error;
    }
  }

  /**
   * å·¥ç¨‹æ›´æ–°æ™‚ã®ãƒãƒ‹ãƒ¥ã‚¢ãƒ«åŒæœŸ
   * Phase 6å®Ÿè£…ç¯„å›²: ã‚¿ã‚¤ãƒˆãƒ«ãƒ»éšå±¤åŒæœŸã®ã¿
   */
  async syncManualFromProcess(processId: string): Promise<SyncResult> {
    const result: SyncResult = {
      success: true,
      updatedCount: 0,
      errors: []
    };

    try {
      // 1. å·¥ç¨‹ã«é–¢é€£ã™ã‚‹ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ¤œç´¢
      const sections = this.getSectionsByProcessId(processId);
      
      if (sections.length === 0) {
        console.log(`[ManualGenerator] å·¥ç¨‹ ${processId} ã«é–¢é€£ã™ã‚‹ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãªã—`);
        return result;
      }

      // 2. å·¥ç¨‹ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
      const process = this.getProcessById(processId);
      if (!process) {
        throw new Error(`å·¥ç¨‹ ${processId} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
      }

      // 3. å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ›´æ–°
      for (const section of sections) {
        // ã‚¿ã‚¤ãƒˆãƒ«ã‚’å·¥ç¨‹åã§æ›´æ–°
        this.updateSection(section.id, {
          heading: process.name,
          syncStatus: 'synced' as const,
          updatedAt: Date.now()
        });
        result.updatedCount++;
      }

      // 4. ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã®æœ€çµ‚åŒæœŸæ—¥æ™‚ã‚’æ›´æ–°
      const manualIds = [...new Set(sections.map(s => s.manualId))];
      for (const manualId of manualIds) {
        this.updateManualSyncTime(manualId);
      }

      console.log(`[ManualGenerator] åŒæœŸå®Œäº†: ${result.updatedCount}ã‚»ã‚¯ã‚·ãƒ§ãƒ³`);
      
    } catch (error) {
      result.success = false;
      result.errors.push(error instanceof Error ? error.message : String(error));
      console.error('[ManualGenerator] åŒæœŸã‚¨ãƒ©ãƒ¼:', error);
    }

    return result;
  }

  /**
   * ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®è‡ªå‹•ç”Ÿæˆ
   * Phase 6å®Ÿè£…ç¯„å›²: ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã®ã¿
   */
  generateSection(process: Process, level: SectionLevel, order: number): ManualSection {
    const now = Date.now();
    
    return {
      id: `sec_${now}_${Math.random().toString(36).substr(2, 9)}`,
      manualId: '', // å¾Œã§è¨­å®š
      sectionOrder: order,
      level: process.level,
      heading: process.name,
      content: this.generatePlaceholderContent(process),
      processId: process.id,
      processLevel: process.level,
      bpmnElementId: process.bpmnElementId,
      parentSectionId: undefined,
      syncStatus: 'synced',
      autoGenerated: true,
      createdAt: now,
      updatedAt: now
    };
  }

  /**
   * ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
   * Phase 6å®Ÿè£…ç¯„å›²: Markdown, HTMLï¼ˆã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ï¼‰, PDFï¼ˆæ§‹é€ ï¼‰
   */
  async exportManual(manualId: string, format: ExportFormat): Promise<string> {
    console.log(`[ManualGenerator] ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆé–‹å§‹: ${format}`);
    
    try {
      const manual = this.getManualById(manualId);
      if (!manual) {
        throw new Error(`ãƒãƒ‹ãƒ¥ã‚¢ãƒ« ${manualId} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
      }

      const sections = this.getSectionsByManualId(manualId);

      switch (format) {
        case 'markdown':
          return this.exportToMarkdown(manual, sections);
        case 'html':
          return this.exportToHtml(manual, sections);
        case 'pdf':
          return this.exportToPdf(manual, sections);
        case 'docx':
          throw new Error('DOCX export is planned for Phase 7');
        default:
          throw new Error(`Unsupported format: ${format}`);
      }
    } catch (error) {
      console.error('[ManualGenerator] ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼:', error);
      throw error;
    }
  }

  // ========== ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ ==========

  private getProcessesByProject(projectId: string, options: GenerateOptions): Process[] {
    let query = `
      SELECT * FROM processes 
      WHERE project_id = ?
    `;
    const params: any[] = [projectId];

    // ãƒ¬ãƒ™ãƒ«ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
    if (options.includeLevels && options.includeLevels.length > 0) {
      const placeholders = options.includeLevels.map(() => '?').join(',');
      query += ` AND level IN (${placeholders})`;
      params.push(...options.includeLevels);
    }

    // ç‰¹å®šå·¥ç¨‹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
    if (options.includeProcessIds && options.includeProcessIds.length > 0) {
      const placeholders = options.includeProcessIds.map(() => '?').join(',');
      query += ` AND id IN (${placeholders})`;
      params.push(...options.includeProcessIds);
    }

    query += ` ORDER BY display_order`;

    const stmt = this.getDb().prepare(query);
    const rows = stmt.all(...params) as any[];
    return rows.map(row => this.mapRowToProcess(row));
  }

  private createManual(projectId: string, title: string, options: GenerateOptions): Manual {
    const now = Date.now();
    const id = `man_${now}_${Math.random().toString(36).substr(2, 9)}`;

    const manual: Manual = {
      id,
      projectId,
      title,
      content: '', // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã®ã¿ãªã®ã§ç©º
      targetProcessLevel: options.includeLevels[0] || 'small',
      version: '1.0.0',
      status: 'draft',
      author: 'System',
      autoGenerated: true,
      lastSyncAt: now,
      createdAt: now,
      updatedAt: now,
      metadata: { template: options.template }
    };

    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜
    const stmt = this.getDb().prepare(`
      INSERT INTO manuals (
        id, project_id, manual_table_id, title, content, target_process_level,
        version, linked_flow_version, status, author,
        auto_generated, last_sync_at, created_at, updated_at, metadata
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(
      manual.id,
      manual.projectId,
      options.manualTableId || null,
      manual.title,
      manual.content,
      manual.targetProcessLevel,
      manual.version,
      null,
      manual.status,
      manual.author,
      manual.autoGenerated ? 1 : 0,
      manual.lastSyncAt,
      manual.createdAt,
      manual.updatedAt,
      manual.metadata ? JSON.stringify(manual.metadata) : null
    );

    return manual;
  }

  private buildSectionStructure(manualId: string, processes: Process[]): ManualSection[] {
    const sections: ManualSection[] = [];
    let order = 0;

    for (const process of processes) {
      const section = this.generateSection(process, this.mapProcessLevelToSectionLevel(process.level), order++);
      section.manualId = manualId;
      sections.push(section);
    }

    return sections;
  }

  private mapProcessLevelToSectionLevel(level: ProcessLevel): SectionLevel {
    const mapping: Record<ProcessLevel, SectionLevel> = {
      'large': 'chapter',
      'medium': 'section',
      'small': 'subsection',
      'detail': 'step'
    };
    return mapping[level];
  }

  private generatePlaceholderContent(process: Process): string {
    // Phase 6: ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆã®ã¿
    let content = '[è©³ç´°ã¯æ‰‹å‹•ã§å…¥åŠ›ã—ã¦ãã ã•ã„]\n\n';
    
    if (process.description) {
      content += `**èª¬æ˜**: ${process.description}\n\n`;
    }
    
    if (process.department) {
      content += `**éƒ¨ç½²**: ${process.department}\n\n`;
    }
    
    if (process.assignee) {
      content += `**æ‹…å½“**: ${process.assignee}\n\n`;
    }
    
    if (process.documentType) {
      content += `**å¸³ç¥¨**: ${process.documentType}\n\n`;
    }

    content += 'ğŸ”® **Phase 7ã§è©³ç´°ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ç”ŸæˆAI ã§è‡ªå‹•ç”Ÿæˆäºˆå®š**\n';
    
    return content;
  }

  private saveSection(section: ManualSection): void {
    const stmt = this.getDb().prepare(`
      INSERT INTO manual_sections (
        id, manual_id, section_order, level, heading, content,
        process_id, process_level, bpmn_element_id, parent_section_id,
        sync_status, auto_generated, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(
      section.id,
      section.manualId,
      section.sectionOrder,
      section.level,
      section.heading,
      section.content,
      section.processId,
      section.processLevel,
      section.bpmnElementId || null,
      section.parentSectionId || null,
      section.syncStatus,
      section.autoGenerated ? 1 : 0,
      section.createdAt,
      section.updatedAt
    );
  }

  private getSectionsByProcessId(processId: string): ManualSection[] {
    const stmt = this.getDb().prepare(`
      SELECT * FROM manual_sections WHERE process_id = ?
    `);
    const rows = stmt.all(processId) as any[];
    return rows.map(row => this.mapRowToSection(row));
  }

  private getSectionsByManualId(manualId: string): ManualSection[] {
    const stmt = this.getDb().prepare(`
      SELECT * FROM manual_sections 
      WHERE manual_id = ?
      ORDER BY section_order
    `);
    const rows = stmt.all(manualId) as any[];
    return rows.map(row => this.mapRowToSection(row));
  }

  private getProcessById(processId: string): Process | null {
    const stmt = this.getDb().prepare('SELECT * FROM processes WHERE id = ?');
    const row = stmt.get(processId) as any;
    return row ? this.mapRowToProcess(row) : null;
  }

  private getManualById(manualId: string): Manual | null {
    const stmt = this.getDb().prepare('SELECT * FROM manuals WHERE id = ?');
    const row = stmt.get(manualId) as any;
    return row ? this.mapRowToManual(row) : null;
  }

  private updateSection(sectionId: string, data: Partial<ManualSection>): void {
    const updates: string[] = [];
    const values: any[] = [];

    if (data.heading !== undefined) {
      updates.push('heading = ?');
      values.push(data.heading);
    }
    if (data.syncStatus !== undefined) {
      updates.push('sync_status = ?');
      values.push(data.syncStatus);
    }
    if (data.updatedAt !== undefined) {
      updates.push('updated_at = ?');
      values.push(data.updatedAt);
    }

    if (updates.length === 0) return;

    values.push(sectionId);
    const stmt = this.getDb().prepare(`
      UPDATE manual_sections 
      SET ${updates.join(', ')}
      WHERE id = ?
    `);
    stmt.run(...values);
  }

  private updateManualSyncTime(manualId: string): void {
    const stmt = this.getDb().prepare(`
      UPDATE manuals 
      SET last_sync_at = ?, updated_at = ?
      WHERE id = ?
    `);
    const now = Date.now();
    stmt.run(now, now, manualId);
  }

  private exportToMarkdown(manual: Manual, sections: ManualSection[]): string {
    let markdown = `# ${manual.title}\n\n`;
    markdown += `**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: ${manual.version}\n`;
    markdown += `**ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: ${manual.status}\n`;
    markdown += `**ä½œæˆæ—¥**: ${new Date(manual.createdAt).toLocaleDateString()}\n\n`;
    markdown += `---\n\n`;

    for (const section of sections) {
      const level = this.getSectionHeaderLevel(section.level);
      markdown += `${'#'.repeat(level)} ${section.heading}\n\n`;
      markdown += `${section.content}\n\n`;
    }

    return markdown;
  }

  private exportToHtml(manual: Manual, sections: ManualSection[]): string {
    let html = `<!DOCTYPE html>\n<html>\n<head>\n`;
    html += `  <meta charset="UTF-8">\n`;
    html += `  <title>${manual.title}</title>\n`;
    html += `  <style>body { font-family: sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }</style>\n`;
    html += `</head>\n<body>\n`;
    html += `  <h1>${manual.title}</h1>\n`;
    html += `  <p><strong>ãƒãƒ¼ã‚¸ãƒ§ãƒ³</strong>: ${manual.version}</p>\n`;
    html += `  <hr>\n`;

    for (const section of sections) {
      const level = this.getSectionHeaderLevel(section.level);
      html += `  <h${level}>${section.heading}</h${level}>\n`;
      html += `  <div>${section.content.replace(/\n/g, '<br>')}</div>\n`;
    }

    html += `</body>\n</html>`;
    return html;
  }

  private exportToPdf(manual: Manual, sections: ManualSection[]): string {
    // Phase 6: HTMLã‚’ãƒ™ãƒ¼ã‚¹ã«PDFç”Ÿæˆï¼ˆç°¡æ˜“å®Ÿè£…ï¼‰
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯puppeteerã‚„pdfkitã‚’ä½¿ç”¨
    const html = this.exportToHtml(manual, sections);
    return `PDF Export (Phase 6: HTML base)\n\n${html}`;
  }

  private getSectionHeaderLevel(level: ProcessLevel): number {
    const mapping: Record<ProcessLevel, number> = {
      'large': 2,
      'medium': 3,
      'small': 4,
      'detail': 5
    };
    return mapping[level];
  }

  private mapRowToProcess(row: any): Process {
    return {
      id: row.id,
      projectId: row.project_id,
      name: row.name,
      level: row.level,
      parentId: row.parent_id || undefined,
      department: row.department || undefined,
      assignee: row.assignee || undefined,
      documentType: row.document_type || undefined,
      description: row.description || undefined,
      bpmnElementId: row.bpmn_element_id || undefined,
      displayOrder: row.display_order,
      metadata: row.metadata ? JSON.parse(row.metadata) : undefined
    };
  }

  private mapRowToManual(row: any): Manual {
    return {
      id: row.id,
      projectId: row.project_id,
      title: row.title,
      content: row.content,
      targetProcessLevel: row.target_process_level,
      version: row.version,
      status: row.status,
      author: row.author,
      autoGenerated: Boolean(row.auto_generated),
      lastSyncAt: row.last_sync_at || undefined,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      metadata: row.metadata ? JSON.parse(row.metadata) : undefined
    };
  }

  private mapRowToSection(row: any): ManualSection {
    return {
      id: row.id,
      manualId: row.manual_id,
      sectionOrder: row.section_order,
      level: row.level,
      heading: row.heading,
      content: row.content,
      processId: row.process_id,
      processLevel: row.process_level,
      bpmnElementId: row.bpmn_element_id || undefined,
      parentSectionId: row.parent_section_id || undefined,
      syncStatus: row.sync_status,
      autoGenerated: Boolean(row.auto_generated),
      createdAt: row.created_at,
      updatedAt: row.updated_at
    };
  }
}

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
export const manualGenerator = new ManualGenerator();
