import { getDatabase } from '../utils/database';

/**
 * マニュアル自動生成サービス
 * Phase 6.2.1 実装
 * 
 * 📝 Phase 6スコープ: アウトライン（構造）のみ生成
 * 🔮 Phase 7: 生成AIで詳細コンテンツ自動生成
 */

export type ProcessLevel = 'large' | 'medium' | 'small' | 'detail';
export type SectionLevel = 'chapter' | 'section' | 'subsection' | 'step';
export type ExportFormat = 'pdf' | 'html' | 'markdown' | 'docx';

export interface Process {
  id: string;
  projectId: string;
  name: string;
  level: ProcessLevel;
  parentId?: string;
  department?: string;
  assignee?: string;
  documentType?: string;
  description?: string;
  bpmnElementId?: string;
  displayOrder: number;
  metadata?: Record<string, any>;
}

export interface Manual {
  id: string;
  projectId: string;
  title: string;
  content: string;
  targetProcessLevel: ProcessLevel;
  version: string;
  status: 'draft' | 'review' | 'approved' | 'outdated';
  author: string;
  autoGenerated: boolean;
  lastSyncAt?: number;
  createdAt: number;
  updatedAt: number;
  metadata?: Record<string, any>;
}

export interface ManualSection {
  id: string;
  manualId: string;
  sectionOrder: number;
  level: ProcessLevel;
  heading: string;
  content: string;
  processId: string;
  processLevel: ProcessLevel;
  bpmnElementId?: string;
  parentSectionId?: string;
  syncStatus: 'synced' | 'outdated' | 'conflict';
  autoGenerated: boolean;
  createdAt: number;
  updatedAt: number;
}

export interface GenerateOptions {
  manualTableId?: string; // マニュアルグループID
  includeLevels: ProcessLevel[];
  includeProcessIds?: string[];
  template?: 'business' | 'operation' | 'flowchart' | 'custom';
  autoSync?: boolean;
  includeBpmnImages?: boolean; // 🔮 Phase 7実装予定
  useAI?: boolean; // 🔮 Phase 7実装予定
  aiProvider?: 'openai' | 'anthropic' | 'custom'; // 🔮 Phase 7実装予定
}

export interface SyncResult {
  success: boolean;
  updatedCount: number;
  errors: string[];
}

export class ManualGenerator {
  private db: ReturnType<typeof getDatabase> | null = null;

  private getDb() {
    if (!this.db) {
      this.db = getDatabase();
    }
    return this.db;
  }

  /**
   * 工程群からマニュアルアウトラインを生成
   * Phase 6実装範囲: 構造のみ
   */
  async generateFromProcesses(
    projectId: string,
    title: string,
    options: GenerateOptions
  ): Promise<Manual> {
    console.log(`[ManualGenerator] アウトライン生成開始: ${title}`);
    
    try {
      // 1. 工程階層を取得
      const processes = this.getProcessesByProject(projectId, options);
      
      // 2. マニュアルを作成
      const manual = this.createManual(projectId, title, options);
      
      // 3. セクション構造を構築
      const sections = this.buildSectionStructure(manual.id, processes);
      
      // 4. セクションを保存
      for (const section of sections) {
        this.saveSection(section);
      }
      
      console.log(`[ManualGenerator] アウトライン生成完了: ${sections.length}セクション`);
      return manual;
      
    } catch (error) {
      console.error('[ManualGenerator] アウトライン生成エラー:', error);
      throw error;
    }
  }

  /**
   * 工程更新時のマニュアル同期
   * Phase 6実装範囲: タイトル・階層同期のみ
   */
  async syncManualFromProcess(processId: string): Promise<SyncResult> {
    const result: SyncResult = {
      success: true,
      updatedCount: 0,
      errors: []
    };

    try {
      // 1. 工程に関連するマニュアルセクションを検索
      const sections = this.getSectionsByProcessId(processId);
      
      if (sections.length === 0) {
        console.log(`[ManualGenerator] 工程 ${processId} に関連するセクションなし`);
        return result;
      }

      // 2. 工程データを取得
      const process = this.getProcessById(processId);
      if (!process) {
        throw new Error(`工程 ${processId} が見つかりません`);
      }

      // 3. 各セクションを更新
      for (const section of sections) {
        // タイトルを工程名で更新
        this.updateSection(section.id, {
          heading: process.name,
          syncStatus: 'synced' as const,
          updatedAt: Date.now()
        });
        result.updatedCount++;
      }

      // 4. マニュアルの最終同期日時を更新
      const manualIds = [...new Set(sections.map(s => s.manualId))];
      for (const manualId of manualIds) {
        this.updateManualSyncTime(manualId);
      }

      console.log(`[ManualGenerator] 同期完了: ${result.updatedCount}セクション`);
      
    } catch (error) {
      result.success = false;
      result.errors.push(error instanceof Error ? error.message : String(error));
      console.error('[ManualGenerator] 同期エラー:', error);
    }

    return result;
  }

  /**
   * マニュアルセクションの自動生成
   * Phase 6実装範囲: プレースホルダーのみ
   */
  generateSection(process: Process, level: SectionLevel, order: number): ManualSection {
    const now = Date.now();
    
    return {
      id: `sec_${now}_${Math.random().toString(36).substr(2, 9)}`,
      manualId: '', // 後で設定
      sectionOrder: order,
      level: process.level,
      heading: process.name,
      content: this.generatePlaceholderContent(process),
      processId: process.id,
      processLevel: process.level,
      bpmnElementId: process.bpmnElementId,
      parentSectionId: undefined,
      syncStatus: 'synced',
      autoGenerated: true,
      createdAt: now,
      updatedAt: now
    };
  }

  /**
   * マニュアルエクスポート
   * Phase 6実装範囲: Markdown, HTML（アウトライン）, PDF（構造）
   */
  async exportManual(manualId: string, format: ExportFormat): Promise<string> {
    console.log(`[ManualGenerator] エクスポート開始: ${format}`);
    
    try {
      const manual = this.getManualById(manualId);
      if (!manual) {
        throw new Error(`マニュアル ${manualId} が見つかりません`);
      }

      const sections = this.getSectionsByManualId(manualId);

      switch (format) {
        case 'markdown':
          return this.exportToMarkdown(manual, sections);
        case 'html':
          return this.exportToHtml(manual, sections);
        case 'pdf':
          return this.exportToPdf(manual, sections);
        case 'docx':
          throw new Error('DOCX export is planned for Phase 7');
        default:
          throw new Error(`Unsupported format: ${format}`);
      }
    } catch (error) {
      console.error('[ManualGenerator] エクスポートエラー:', error);
      throw error;
    }
  }

  // ========== プライベートヘルパーメソッド ==========

  private getProcessesByProject(projectId: string, options: GenerateOptions): Process[] {
    let query = `
      SELECT * FROM processes 
      WHERE project_id = ?
    `;
    const params: any[] = [projectId];

    // レベルフィルター
    if (options.includeLevels && options.includeLevels.length > 0) {
      const placeholders = options.includeLevels.map(() => '?').join(',');
      query += ` AND level IN (${placeholders})`;
      params.push(...options.includeLevels);
    }

    // 特定工程フィルター
    if (options.includeProcessIds && options.includeProcessIds.length > 0) {
      const placeholders = options.includeProcessIds.map(() => '?').join(',');
      query += ` AND id IN (${placeholders})`;
      params.push(...options.includeProcessIds);
    }

    query += ` ORDER BY display_order`;

    const stmt = this.getDb().prepare(query);
    const rows = stmt.all(...params) as any[];
    return rows.map(row => this.mapRowToProcess(row));
  }

  private createManual(projectId: string, title: string, options: GenerateOptions): Manual {
    const now = Date.now();
    const id = `man_${now}_${Math.random().toString(36).substr(2, 9)}`;

    const manual: Manual = {
      id,
      projectId,
      title,
      content: '', // アウトラインのみなので空
      targetProcessLevel: options.includeLevels[0] || 'small',
      version: '1.0.0',
      status: 'draft',
      author: 'System',
      autoGenerated: true,
      lastSyncAt: now,
      createdAt: now,
      updatedAt: now,
      metadata: { template: options.template }
    };

    // データベースに保存
    const stmt = this.getDb().prepare(`
      INSERT INTO manuals (
        id, project_id, manual_table_id, title, content, target_process_level,
        version, linked_flow_version, status, author,
        auto_generated, last_sync_at, created_at, updated_at, metadata
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(
      manual.id,
      manual.projectId,
      options.manualTableId || null,
      manual.title,
      manual.content,
      manual.targetProcessLevel,
      manual.version,
      null,
      manual.status,
      manual.author,
      manual.autoGenerated ? 1 : 0,
      manual.lastSyncAt,
      manual.createdAt,
      manual.updatedAt,
      manual.metadata ? JSON.stringify(manual.metadata) : null
    );

    return manual;
  }

  private buildSectionStructure(manualId: string, processes: Process[]): ManualSection[] {
    const sections: ManualSection[] = [];
    let order = 0;

    for (const process of processes) {
      const section = this.generateSection(process, this.mapProcessLevelToSectionLevel(process.level), order++);
      section.manualId = manualId;
      sections.push(section);
    }

    return sections;
  }

  private mapProcessLevelToSectionLevel(level: ProcessLevel): SectionLevel {
    const mapping: Record<ProcessLevel, SectionLevel> = {
      'large': 'chapter',
      'medium': 'section',
      'small': 'subsection',
      'detail': 'step'
    };
    return mapping[level];
  }

  private generatePlaceholderContent(process: Process): string {
    // Phase 6: プレースホルダーテキストのみ
    let content = '[詳細は手動で入力してください]\n\n';
    
    if (process.description) {
      content += `**説明**: ${process.description}\n\n`;
    }
    
    if (process.department) {
      content += `**部署**: ${process.department}\n\n`;
    }
    
    if (process.assignee) {
      content += `**担当**: ${process.assignee}\n\n`;
    }
    
    if (process.documentType) {
      content += `**帳票**: ${process.documentType}\n\n`;
    }

    content += '🔮 **Phase 7で詳細コンテンツを生成AI で自動生成予定**\n';
    
    return content;
  }

  private saveSection(section: ManualSection): void {
    const stmt = this.getDb().prepare(`
      INSERT INTO manual_sections (
        id, manual_id, section_order, level, heading, content,
        process_id, process_level, bpmn_element_id, parent_section_id,
        sync_status, auto_generated, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(
      section.id,
      section.manualId,
      section.sectionOrder,
      section.level,
      section.heading,
      section.content,
      section.processId,
      section.processLevel,
      section.bpmnElementId || null,
      section.parentSectionId || null,
      section.syncStatus,
      section.autoGenerated ? 1 : 0,
      section.createdAt,
      section.updatedAt
    );
  }

  private getSectionsByProcessId(processId: string): ManualSection[] {
    const stmt = this.getDb().prepare(`
      SELECT * FROM manual_sections WHERE process_id = ?
    `);
    const rows = stmt.all(processId) as any[];
    return rows.map(row => this.mapRowToSection(row));
  }

  private getSectionsByManualId(manualId: string): ManualSection[] {
    const stmt = this.getDb().prepare(`
      SELECT * FROM manual_sections 
      WHERE manual_id = ?
      ORDER BY section_order
    `);
    const rows = stmt.all(manualId) as any[];
    return rows.map(row => this.mapRowToSection(row));
  }

  private getProcessById(processId: string): Process | null {
    const stmt = this.getDb().prepare('SELECT * FROM processes WHERE id = ?');
    const row = stmt.get(processId) as any;
    return row ? this.mapRowToProcess(row) : null;
  }

  private getManualById(manualId: string): Manual | null {
    const stmt = this.getDb().prepare('SELECT * FROM manuals WHERE id = ?');
    const row = stmt.get(manualId) as any;
    return row ? this.mapRowToManual(row) : null;
  }

  private updateSection(sectionId: string, data: Partial<ManualSection>): void {
    const updates: string[] = [];
    const values: any[] = [];

    if (data.heading !== undefined) {
      updates.push('heading = ?');
      values.push(data.heading);
    }
    if (data.syncStatus !== undefined) {
      updates.push('sync_status = ?');
      values.push(data.syncStatus);
    }
    if (data.updatedAt !== undefined) {
      updates.push('updated_at = ?');
      values.push(data.updatedAt);
    }

    if (updates.length === 0) return;

    values.push(sectionId);
    const stmt = this.getDb().prepare(`
      UPDATE manual_sections 
      SET ${updates.join(', ')}
      WHERE id = ?
    `);
    stmt.run(...values);
  }

  private updateManualSyncTime(manualId: string): void {
    const stmt = this.getDb().prepare(`
      UPDATE manuals 
      SET last_sync_at = ?, updated_at = ?
      WHERE id = ?
    `);
    const now = Date.now();
    stmt.run(now, now, manualId);
  }

  private exportToMarkdown(manual: Manual, sections: ManualSection[]): string {
    let markdown = `# ${manual.title}\n\n`;
    markdown += `**バージョン**: ${manual.version}\n`;
    markdown += `**ステータス**: ${manual.status}\n`;
    markdown += `**作成日**: ${new Date(manual.createdAt).toLocaleDateString()}\n\n`;
    markdown += `---\n\n`;

    for (const section of sections) {
      const level = this.getSectionHeaderLevel(section.level);
      markdown += `${'#'.repeat(level)} ${section.heading}\n\n`;
      markdown += `${section.content}\n\n`;
    }

    return markdown;
  }

  private exportToHtml(manual: Manual, sections: ManualSection[]): string {
    let html = `<!DOCTYPE html>\n<html>\n<head>\n`;
    html += `  <meta charset="UTF-8">\n`;
    html += `  <title>${manual.title}</title>\n`;
    html += `  <style>body { font-family: sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }</style>\n`;
    html += `</head>\n<body>\n`;
    html += `  <h1>${manual.title}</h1>\n`;
    html += `  <p><strong>バージョン</strong>: ${manual.version}</p>\n`;
    html += `  <hr>\n`;

    for (const section of sections) {
      const level = this.getSectionHeaderLevel(section.level);
      html += `  <h${level}>${section.heading}</h${level}>\n`;
      html += `  <div>${section.content.replace(/\n/g, '<br>')}</div>\n`;
    }

    html += `</body>\n</html>`;
    return html;
  }

  private exportToPdf(manual: Manual, sections: ManualSection[]): string {
    // Phase 6: HTMLをベースにPDF生成（簡易実装）
    // 実際の実装ではpuppeteerやpdfkitを使用
    const html = this.exportToHtml(manual, sections);
    return `PDF Export (Phase 6: HTML base)\n\n${html}`;
  }

  private getSectionHeaderLevel(level: ProcessLevel): number {
    const mapping: Record<ProcessLevel, number> = {
      'large': 2,
      'medium': 3,
      'small': 4,
      'detail': 5
    };
    return mapping[level];
  }

  private mapRowToProcess(row: any): Process {
    return {
      id: row.id,
      projectId: row.project_id,
      name: row.name,
      level: row.level,
      parentId: row.parent_id || undefined,
      department: row.department || undefined,
      assignee: row.assignee || undefined,
      documentType: row.document_type || undefined,
      description: row.description || undefined,
      bpmnElementId: row.bpmn_element_id || undefined,
      displayOrder: row.display_order,
      metadata: row.metadata ? JSON.parse(row.metadata) : undefined
    };
  }

  private mapRowToManual(row: any): Manual {
    return {
      id: row.id,
      projectId: row.project_id,
      title: row.title,
      content: row.content,
      targetProcessLevel: row.target_process_level,
      version: row.version,
      status: row.status,
      author: row.author,
      autoGenerated: Boolean(row.auto_generated),
      lastSyncAt: row.last_sync_at || undefined,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      metadata: row.metadata ? JSON.parse(row.metadata) : undefined
    };
  }

  private mapRowToSection(row: any): ManualSection {
    return {
      id: row.id,
      manualId: row.manual_id,
      sectionOrder: row.section_order,
      level: row.level,
      heading: row.heading,
      content: row.content,
      processId: row.process_id,
      processLevel: row.process_level,
      bpmnElementId: row.bpmn_element_id || undefined,
      parentSectionId: row.parent_section_id || undefined,
      syncStatus: row.sync_status,
      autoGenerated: Boolean(row.auto_generated),
      createdAt: row.created_at,
      updatedAt: row.updated_at
    };
  }
}

// シングルトンインスタンス
export const manualGenerator = new ManualGenerator();
